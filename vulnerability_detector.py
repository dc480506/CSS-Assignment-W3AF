import requests,pymysql
# import re # uncomment this for DVWA
from bs4 import BeautifulSoup as bs
from urllib.parse import urljoin
import pprint
import tkinter as tk
s = requests.Session()
s.headers["User-Agent"] = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.106 Safari/537.36"

# below code is for logging to your local DVWA
# uncomment it if you want to use this on DVWA
# login_payload = {
#     "username": "admin",
#     "password": "password",
#     "Login": "Login",
# }
# # change URL to the login page of your DVWA login URL
# login_url = "http://localhost:8080/DVWA-master/login.php"

# # login
# r = s.get(login_url)
# token = re.search("user_token'\s*value='(.*?)'", r.text).group(1)
# login_payload['user_token'] = token
# s.post(login_url, data=login_payload)


def get_all_forms(url):
    """Given a `url`, it returns all forms from the HTML content"""
    soup = bs(s.get(url).content, "html.parser")
    return soup.find_all("form")


def get_form_details(form):
    """
    This function extracts all possible useful information about an HTML `form`
    """
    details = {}
    # get the form action (target url)
    try:
        action = form.attrs.get("action").lower()
    except:
        action = None
    # get the form method (POST, GET, etc.)
    method = form.attrs.get("method", "get").lower()
    # get all the input details such as type and name
    inputs = []
    for input_tag in form.find_all("input"):
        input_type = input_tag.attrs.get("type", "text")
        input_name = input_tag.attrs.get("name")
        input_value = input_tag.attrs.get("value", "")
        inputs.append({"type": input_type, "name": input_name, "value": input_value})
    buttons=[]
    for button in form.find_all("button"):
        input_type = button.attrs.get("type", "text")
        input_name = button.attrs.get("name")
        input_value = button.attrs.get("value", "")
        buttons.append({"type": input_type, "name": input_name, "value": input_value})

    # put everything to the resulting dictionary
    details["action"] = action
    details["method"] = method
    details["inputs"] = inputs
    details["buttons"] = buttons

    return details


def is_sql_vulnerable(response):
    """A simple boolean function that determines whether a page 
    is SQL Injection vulnerable from its `response`"""
    # print(response.content.decode())
    errors = {
        # MySQL
        "you have an error in your sql syntax;",
        "warning: mysql",
        "<b>warning</b>: mysql",
        "expects parameter 1 to be mysqli_result",
        # SQL Server
        "unclosed quotation mark after the character string",
        # Oracle
        "quoted string not properly terminated",
    }
    for error in errors:
        # if you find one of these errors, return True
        if error in response.content.decode().lower():
            return True
    # no error detected
    return False


def scan_sql_injection(url,self):
    connection = pymysql.connect(host='localhost',user='root',passwd='',database='w3aef')
    cursor = connection.cursor()
    # test on URL
    sql_vulnerable=False
    for c in "\"'":
        # add quote/double quote character to the URL
        new_url = f"{url}{c}"
        print("[!] Trying", new_url)
        self.sql_injection_scroll.insert(tk.INSERT,"[!] Trying \n"+new_url+"\n\n")
        # make the HTTP request
        res = s.get(new_url)
        if is_sql_vulnerable(res):
            sql_vulnerable=True
            # SQL Injection detected on the URL itself, 
            # no need to preceed for extracting forms and submitting them
            print("[+] SQL Injection vulnerability detected, link:", new_url)
            self.sql_injection_scroll.insert(tk.INSERT,"[+] SQL Injection vulnerability detected, link:"+new_url+"\n\n")
            break
    # test on HTML forms
    forms = get_all_forms(url)
    print(f"[+] Detected {len(forms)} forms on {url}.")
    self.sql_injection_scroll.insert(tk.INSERT,f"[+] Detected {len(forms)} forms on {url}."+"\n\n")
    for form in forms:
        form_details = get_form_details(form)
        for c in "\"'":
            # the data body we want to submit
            data = {}
            for input_tag in form_details["inputs"]:
                if input_tag["value"] or input_tag["type"] == "hidden":
                    # any input form that has some value or hidden,
                    # just use it in the form body
                    try:
                        data[input_tag["name"]] = input_tag["value"] + c
                    except:
                        pass
                elif input_tag["type"] != "submit":
                    # all others except submit, use some junk data with special character
                    data[input_tag["name"]] = f"test{c}"
                elif input_tag["type"]=="submit":
                    data[input_tag["name"]] = "1"
            for button in form_details["buttons"]:
                if button["type"] == "submit":
                	data[button["name"]]=button["value"]
            # join the url with the action (form request URL)
            # print(data)
            url = urljoin(url, form_details["action"])
            if form_details["method"] == "post":
                res = s.post(url, data=data)
            elif form_details["method"] == "get":
                res = s.get(url, params=data)
            # test whether the resulting page is vulnerable
            if is_sql_vulnerable(res):
                sql_vulnerable=True
                print("[+] SQL Injection vulnerability detected, link:", url)
                self.sql_injection_scroll.insert(tk.INSERT,"[+] SQL Injection vulnerability detected,\n link:"+url+"\n")
                print("[+] Form:")
                # self.sql_injection_scroll.tag_configure("red", foreground="red")
                # apply the tag "red" 
                # self.sql_injection_scroll.highlight_pattern(url, "red")
                # self.sql_injection_scroll.insert(tk.INSERT,"[+] Form:\n")
                pprint.pprint(form_details)
                self.sql_injection_scroll.insert(tk.INSERT,pprint.pformat(form_details)+"\n\n")
                break
                insert="""INSERT INTO logger(url,flag,details) VALUES"""
                values=(url,0,str(form_details))
                insert_values=insert+str(values)
                cursor.execute(insert_values)
                connection.commit()   
    if not sql_vulnerable:
        self.sql_injection_scroll.insert(tk.INSERT,"Scan Successful. No SQL Injection vulnerabilities found\n")
        insert="""INSERT INTO logger(url,flag,details) VALUES"""
        values=(url,0,"No sql injection")
        insert_values=insert+str(values)
        cursor.execute(insert_values)
        connection.commit()

def submit_form(form_details, url, value):
    """
    Submits a form given in `form_details`
    Params:
        form_details (list): a dictionary that contain form information
        url (str): the original URL that contain that form
        value (str): this will be replaced to all text and search inputs
    Returns the HTTP Response after form submission
    """
    # construct the full URL (if the url provided in action is relative)
    target_url = urljoin(url, form_details["action"])
    # get the inputs
    inputs = form_details["inputs"]
    buttons= form_details["buttons"]
    data = {}
    for input in inputs:
        # replace all text and search values with `value`
        if input["type"] == "text" or input["type"] == "search":
            input["value"] = value
        input_name = input.get("name")
        input_value = input.get("value")
        if input_name and input_value:
            # if input name and value are not None, 
            # then add them to the data of form submission
            data[input_name] = input_value
    for button in buttons:
        if button["type"]=="submit":
            data[button["name"]]=""
    if form_details["method"] == "post":
        return requests.post(target_url, data=data)
    else:
        # GET request
        return requests.get(target_url, params=data)


def scan_xss(url,self):
    """
    Given a `url`, it prints all XSS vulnerable forms and 
    returns True if any is vulnerable, False otherwise
    """
    # get all the forms from the URL
    connection = pymysql.connect(host='localhost',user='root',passwd='',database='w3aef')
    cursor = connection.cursor()
    forms = get_all_forms(url)
    print(f"[+] Detected {len(forms)} forms on {url}.")
    self.xss_detection_scroll.insert(tk.INSERT,f"[+] Detected {len(forms)} forms on {url}."+"\n\n")

    js_script = "<Script>alert('hi')</scripT>"
    # returning value
    is_vulnerable = False
    # iterate over all forms
    for form in forms:
        form_details = get_form_details(form)
        content = submit_form(form_details, url, js_script).content.decode()
        if js_script in content:
            print(f"[+] XSS Detected on {url}")
            self.xss_detection_scroll.insert(tk.INSERT,"[+] XSS detected,\n link:"+url+"\n")
            print(f"[*] Form details:")
            self.xss_detection_scroll.insert(tk.INSERT,"[*] Form details:\n")

            self.xss_detection_scroll.insert(tk.INSERT,pprint.pformat(form_details)+"\n\n")

            pprint.pprint(form_details)
            is_vulnerable = True
            insert="""INSERT INTO logger(url,flag,details) VALUES"""
            values=(url,1,str(form_details))
            insert_values=insert+str(values)
            cursor.execute(insert_values)
            connection.commit()
    if not is_vulnerable:
        self.xss_detection_scroll.insert(tk.INSERT,"[+] XSS vulnerability not found\n")
        insert="""INSERT INTO logger(url,flag,details) VALUES"""
        values=(url,1,"No XSS vulnerablity")
        insert_values=insert+str(values)
        cursor.execute(insert_values)
        connection.commit()
       
    return is_vulnerable
def logger(self):
    connection = pymysql.connect(host='localhost',user='root',passwd='',database='w3aef')
    cursor = connection.cursor()
    print("Logger")
    self.logger_scroll.insert(tk.INSERT,"XSS Vulnerablity"+"\n")
    query="""SELECT * FROM logger where flag=1"""
    print(query)
    cursor.execute(query)
    options = cursor.fetchall()
    for rows in options:
        self.logger_scroll.insert(tk.INSERT,"URL:"+rows[0]+"\n")
        self.logger_scroll.insert(tk.INSERT,"Output:"+pprint.pformat(rows[2])+"\n")
    print(options)
    self.logger_scroll.insert(tk.INSERT,"SQL Injection"+"\n")
    query="""SELECT * FROM logger where flag=0"""
    cursor.execute(query)
    sql = cursor.fetchall()
    for rows in sql:
        self.logger_scroll.insert(tk.INSERT,"URL:"+rows[0]+"\n")
        self.logger_scroll.insert(tk.INSERT,"Output:"+pprint.pformat(rows[2])+"\n")
    print(sql)

if __name__ == "__main__":
    import sys
    url = input()
    scan_sql_injection(url)
    scan_xss(url)
    logger()
